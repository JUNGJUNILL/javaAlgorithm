package codility;

public class LESSON03_TapeEquilibrium {

	public static void main(String[] args) {
	/*
	 N개의 정수로 구성된 비어 있지 않은 배열 A가 제공됩니다. 
	 배열 A는 테이프에 있는 숫자를 나타냅니다.
	
	0 < P < N과 같은 정수 P는 이 테이프를 비어 있지 않은 두 부분으로 분할합니다. 
	A[0], A[1], ..., A[P - 1], A[P + 1], ..., A[N - 1]
	
	두 부분의 차이는 |(A[0] + A[1] + ...의 값입니다. + A[P - 1] - (A[P] + A[P + 1] + ... + A[N - 1]|
	
	즉, 첫 번째 부분의 합과 두 번째 부분의 합 사이의 절대적인 차이입니다.
	
	예를 들어 다음과 같은 배열 A를 생각해 보십시오.
	
	A[0] = 3
	A[1] = 1
	A[2] = 2
	A[3] = 4
	A[4] = 3
	이 테이프를 네 군데로 나눌 수 있습니다.
	
	P = 1, 차이 = |3 - 10| = 7
	P = 2, 차이 = |4 - 9| = 5
	P = 3, 차이 = |6 - 7| = 1
	P = 4, 차이 = |10 - 3| = 7
	함수 쓰기:
	
	클래스 솔루션 {public int 솔루션(int[] A); }
	
	N개의 정수로 구성된 비어 있지 않은 배열 A가 주어지면 얻을 수 있는 최소 차이를 반환합니다.
	
	예를 들어, 다음과 같습니다.
	
	A[0] = 3
	A[1] = 1
	A[2] = 2
	A[3] = 4
	A[4] = 3
	위에서 설명한 대로 함수는 1을 반환해야 합니다.
	
	다음 가정에 대한 효율적인 알고리즘을 작성하십시오.
	
	N은 [2..] 범위 내의 정수입니다.100,000];
	배열 A의 각 요소는 [-1,000..1000] 범위 내의 정수입니다.
	*/
	}

}
